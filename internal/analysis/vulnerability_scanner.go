// Package analysis provides vulnerability scanning functionality for SBOM components.
package analysis

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/chrisclapham/SBOM-Sentinel/internal/core"
)

// VulnerabilityScanningAgent analyzes SBOM components for known vulnerabilities using OSV.dev API.
type VulnerabilityScanningAgent struct {
	httpClient *http.Client
	apiBaseURL string
}

// OSVVulnerability represents a vulnerability record from OSV.dev API.
type OSVVulnerability struct {
	ID      string `json:"id"`
	Summary string `json:"summary"`
	Details string `json:"details"`
	Aliases []string `json:"aliases"`
	Severity []struct {
		Type  string `json:"type"`
		Score string `json:"score"`
	} `json:"severity"`
	DatabaseSpecific struct {
		Severity string `json:"severity"`
	} `json:"database_specific"`
}

// OSVQueryRequest represents the request format for OSV.dev API queries.
type OSVQueryRequest struct {
	Package struct {
		Name      string `json:"name"`
		Ecosystem string `json:"ecosystem"`
	} `json:"package"`
	Version string `json:"version,omitempty"`
}

// OSVQueryResponse represents the response format from OSV.dev API.
type OSVQueryResponse struct {
	Vulns []OSVVulnerability `json:"vulns"`
}

// NewVulnerabilityScanningAgent creates a new instance of VulnerabilityScanningAgent.
func NewVulnerabilityScanningAgent() *VulnerabilityScanningAgent {
	return &VulnerabilityScanningAgent{
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		apiBaseURL: "https://api.osv.dev/v1",
	}
}

// Name returns the identifier for this analysis agent.
func (vsa *VulnerabilityScanningAgent) Name() string {
	return "Vulnerability Scanner"
}

// Analyze examines the SBOM components for known vulnerabilities using OSV.dev API.
// It returns a slice of AnalysisResult containing findings for components
// that have known vulnerabilities in the OSV database.
func (vsa *VulnerabilityScanningAgent) Analyze(ctx context.Context, sbom core.SBOM) ([]core.AnalysisResult, error) {
	var results []core.AnalysisResult

	for _, component := range sbom.Components {
		// Skip components without sufficient information for vulnerability lookup
		if component.Name == "" {
			continue
		}

		// Query OSV.dev for vulnerabilities
		vulns, err := vsa.queryOSVForComponent(ctx, component)
		if err != nil {
			// Log the error but continue with other components
			fmt.Printf("Warning: Failed to query OSV for component %s: %v\n", component.Name, err)
			continue
		}

		// Create analysis results for each vulnerability found
		for _, vuln := range vulns {
			severity := vsa.determineSeverity(vuln)
			finding := vsa.createFindingMessage(component, vuln)

			result := core.AnalysisResult{
				AgentName: vsa.Name(),
				Finding:   finding,
				Severity:  severity,
			}

			results = append(results, result)
		}
	}

	return results, nil
}

// queryOSVForComponent queries the OSV.dev API for vulnerabilities affecting the given component.
func (vsa *VulnerabilityScanningAgent) queryOSVForComponent(ctx context.Context, component core.Component) ([]OSVVulnerability, error) {
	ecosystem := vsa.extractEcosystemFromPURL(component.PURL)
	if ecosystem == "" {
		// If we can't determine the ecosystem, try to infer it from the component name
		ecosystem = vsa.inferEcosystem(component.Name)
	}

	// If we still can't determine the ecosystem, skip this component
	if ecosystem == "" {
		return nil, nil
	}

	// Prepare the query request
	queryReq := OSVQueryRequest{}
	queryReq.Package.Name = component.Name
	queryReq.Package.Ecosystem = ecosystem
	if component.Version != "" {
		queryReq.Version = component.Version
	}

	// Marshal the request to JSON
	reqBody, err := json.Marshal(queryReq)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal OSV query request: %w", err)
	}

	// Create HTTP request
	req, err := http.NewRequestWithContext(ctx, "POST", vsa.apiBaseURL+"/query", strings.NewReader(string(reqBody)))
	if err != nil {
		return nil, fmt.Errorf("failed to create HTTP request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "SBOM-Sentinel/1.0")

	// Execute the request
	resp, err := vsa.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute OSV API request: %w", err)
	}
	defer resp.Body.Close()

	// Handle non-200 status codes
	if resp.StatusCode != http.StatusOK {
		if resp.StatusCode == 404 {
			// No vulnerabilities found for this component
			return nil, nil
		}
		return nil, fmt.Errorf("OSV API returned status code %d", resp.StatusCode)
	}

	// Parse the response
	var queryResp OSVQueryResponse
	if err := json.NewDecoder(resp.Body).Decode(&queryResp); err != nil {
		return nil, fmt.Errorf("failed to decode OSV API response: %w", err)
	}

	return queryResp.Vulns, nil
}

// extractEcosystemFromPURL extracts the ecosystem from a Package URL (PURL).
func (vsa *VulnerabilityScanningAgent) extractEcosystemFromPURL(purl string) string {
	if purl == "" {
		return ""
	}

	// PURL format: pkg:type/namespace/name@version
	if !strings.HasPrefix(purl, "pkg:") {
		return ""
	}

	parts := strings.Split(purl, "/")
	if len(parts) < 2 {
		return ""
	}

	// Extract the type (ecosystem) part
	typePart := parts[0]
	if strings.HasPrefix(typePart, "pkg:") {
		ecosystem := strings.TrimPrefix(typePart, "pkg:")
		return vsa.mapPURLTypeToOSVEcosystem(ecosystem)
	}

	return ""
}

// mapPURLTypeToOSVEcosystem maps PURL types to OSV ecosystem names.
func (vsa *VulnerabilityScanningAgent) mapPURLTypeToOSVEcosystem(purlType string) string {
	switch strings.ToLower(purlType) {
	case "npm":
		return "npm"
	case "pypi":
		return "PyPI"
	case "maven":
		return "Maven"
	case "cargo":
		return "crates.io"
	case "golang", "go":
		return "Go"
	case "nuget":
		return "NuGet"
	case "composer":
		return "Packagist"
	case "gem":
		return "RubyGems"
	default:
		return ""
	}
}

// inferEcosystem attempts to infer the ecosystem from the component name.
func (vsa *VulnerabilityScanningAgent) inferEcosystem(name string) string {
	// This is a basic heuristic - in a real-world scenario, you might want
	// more sophisticated inference logic
	lowerName := strings.ToLower(name)
	
	// Check for common patterns
	if strings.Contains(lowerName, ".jar") || strings.Contains(lowerName, "org.") || strings.Contains(lowerName, "com.") {
		return "Maven"
	}
	if strings.Contains(lowerName, "@") {
		return "npm"
	}
	if strings.Contains(lowerName, "::") {
		return "crates.io"
	}
	
	// Default to empty string if we can't infer
	return ""
}

// determineSeverity assigns a severity level based on the vulnerability information.
func (vsa *VulnerabilityScanningAgent) determineSeverity(vuln OSVVulnerability) string {
	// Check if there's severity information in the vulnerability
	if len(vuln.Severity) > 0 {
		for _, sev := range vuln.Severity {
			if sev.Type == "CVSS_V3" {
				// Parse CVSS score if available
				score := sev.Score
				if strings.Contains(score, "CRITICAL") || strings.Contains(score, "9.") {
					return "Critical"
				}
				if strings.Contains(score, "HIGH") || strings.Contains(score, "7.") || strings.Contains(score, "8.") {
					return "High"
				}
				if strings.Contains(score, "MEDIUM") || strings.Contains(score, "4.") || strings.Contains(score, "5.") || strings.Contains(score, "6.") {
					return "Medium"
				}
				return "Low"
			}
		}
	}

	// Check database-specific severity
	if vuln.DatabaseSpecific.Severity != "" {
		switch strings.ToUpper(vuln.DatabaseSpecific.Severity) {
		case "CRITICAL":
			return "Critical"
		case "HIGH":
			return "High"
		case "MEDIUM", "MODERATE":
			return "Medium"
		case "LOW":
			return "Low"
		}
	}

	// Check if this is a well-known high-severity CVE based on aliases
	for _, alias := range vuln.Aliases {
		if strings.HasPrefix(alias, "CVE-") {
			// For now, treat all CVEs as High severity if no other info available
			return "High"
		}
	}

	// Default to Medium if we can't determine severity
	return "Medium"
}

// createFindingMessage creates a descriptive finding message for a vulnerability.
func (vsa *VulnerabilityScanningAgent) createFindingMessage(component core.Component, vuln OSVVulnerability) string {
	var aliases []string
	for _, alias := range vuln.Aliases {
		if strings.HasPrefix(alias, "CVE-") {
			aliases = append(aliases, alias)
		}
	}

	versionInfo := ""
	if component.Version != "" {
		versionInfo = fmt.Sprintf(" (v%s)", component.Version)
	}

	aliasInfo := ""
	if len(aliases) > 0 {
		aliasInfo = fmt.Sprintf(" [%s]", strings.Join(aliases, ", "))
	}

	summary := vuln.Summary
	if summary == "" && len(aliases) > 0 {
		summary = fmt.Sprintf("Known vulnerability %s", aliases[0])
	}
	if summary == "" {
		summary = "Known vulnerability detected"
	}

	return fmt.Sprintf("Component '%s'%s has a known vulnerability%s: %s (OSV ID: %s)",
		component.Name,
		versionInfo,
		aliasInfo,
		summary,
		vuln.ID)
}