package analysis

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/hueyexe/SBOM-Sentinel/internal/core"
	"github.com/stretchr/testify/assert"
)

func TestVulnerabilityScanningAgent_Name(t *testing.T) {
	agent := NewVulnerabilityScanningAgent()
	assert.Equal(t, "Vulnerability Scanner", agent.Name())
}

func TestVulnerabilityScanningAgent_Analyze(t *testing.T) {
	tests := []struct {
		name               string
		sbom               core.SBOM
		mockResponse       OSVQueryResponse
		mockStatusCode     int
		expectedCount      int
		expectedSeverities []string
		expectedCVEs       []string
	}{
		{
			name: "Component with high severity vulnerability",
			sbom: core.SBOM{
				ID:   "test-1",
				Name: "Test SBOM",
				Components: []core.Component{
					{
						Name:    "vulnerable-package",
						Version: "1.0.0",
						PURL:    "pkg:npm/vulnerable-package@1.0.0",
					},
				},
			},
			mockResponse: OSVQueryResponse{
				Vulns: []OSVVulnerability{
					{
						ID:      "OSV-2023-001",
						Summary: "Critical security vulnerability",
						Aliases: []string{"CVE-2023-12345"},
						Severity: []struct {
							Type  string `json:"type"`
							Score string `json:"score"`
						}{
							{Type: "CVSS_V3", Score: "9.0"},
						},
					},
				},
			},
			mockStatusCode:     http.StatusOK,
			expectedCount:      1,
			expectedSeverities: []string{"Critical"},
			expectedCVEs:       []string{"CVE-2023-12345"},
		},
		{
			name: "Component with multiple vulnerabilities",
			sbom: core.SBOM{
				ID:   "test-2",
				Name: "Test SBOM",
				Components: []core.Component{
					{
						Name:    "multi-vuln-package",
						Version: "2.0.0",
						PURL:    "pkg:pypi/multi-vuln-package@2.0.0",
					},
				},
			},
			mockResponse: OSVQueryResponse{
				Vulns: []OSVVulnerability{
					{
						ID:      "OSV-2023-002",
						Summary: "High security vulnerability",
						Aliases: []string{"CVE-2023-11111"},
						Severity: []struct {
							Type  string `json:"type"`
							Score string `json:"score"`
						}{
							{Type: "CVSS_V3", Score: "8.0"},
						},
					},
					{
						ID:      "OSV-2023-003",
						Summary: "Medium security vulnerability",
						Aliases: []string{"CVE-2023-22222"},
						DatabaseSpecific: struct {
							Severity string `json:"severity"`
						}{Severity: "MEDIUM"},
					},
				},
			},
			mockStatusCode:     http.StatusOK,
			expectedCount:      2,
			expectedSeverities: []string{"High", "Medium"},
			expectedCVEs:       []string{"CVE-2023-11111", "CVE-2023-22222"},
		},
		{
			name: "Component with no vulnerabilities (404 response)",
			sbom: core.SBOM{
				ID:   "test-3",
				Name: "Test SBOM",
				Components: []core.Component{
					{
						Name:    "safe-package",
						Version: "3.0.0",
						PURL:    "pkg:maven/com.example/safe-package@3.0.0",
					},
				},
			},
			mockResponse:   OSVQueryResponse{},
			mockStatusCode: http.StatusNotFound,
			expectedCount:  0,
		},
		{
			name: "Component without PURL - ecosystem inference",
			sbom: core.SBOM{
				ID:   "test-4",
				Name: "Test SBOM",
				Components: []core.Component{
					{
						Name:    "org.springframework.boot",
						Version: "2.5.0",
					},
				},
			},
			mockResponse: OSVQueryResponse{
				Vulns: []OSVVulnerability{
					{
						ID:      "OSV-2023-004",
						Summary: "Spring Boot vulnerability",
						Aliases: []string{"CVE-2023-33333"},
					},
				},
			},
			mockStatusCode:     http.StatusOK,
			expectedCount:      1,
			expectedSeverities: []string{"High"}, // Default for CVE
			expectedCVEs:       []string{"CVE-2023-33333"},
		},
		{
			name: "Component without name - should be skipped",
			sbom: core.SBOM{
				ID:   "test-5",
				Name: "Test SBOM",
				Components: []core.Component{
					{
						Name:    "",
						Version: "1.0.0",
					},
				},
			},
			mockStatusCode: http.StatusOK,
			expectedCount:  0,
		},
		{
			name: "Empty SBOM",
			sbom: core.SBOM{
				ID:         "test-6",
				Name:       "Empty SBOM",
				Components: []core.Component{},
			},
			mockStatusCode: http.StatusOK,
			expectedCount:  0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock server
			mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				// Verify request method and headers
				assert.Equal(t, "POST", r.Method)
				assert.Equal(t, "application/json", r.Header.Get("Content-Type"))
				assert.Equal(t, "SBOM-Sentinel/1.0", r.Header.Get("User-Agent"))

				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(tt.mockStatusCode)

				if tt.mockStatusCode == http.StatusOK {
					responseBytes, _ := json.Marshal(tt.mockResponse)
					w.Write(responseBytes)
				}
			}))
			defer mockServer.Close()

			// Create agent with custom API URL
			agent := NewVulnerabilityScanningAgent()
			agent.apiBaseURL = mockServer.URL

			ctx := context.Background()
			results, err := agent.Analyze(ctx, tt.sbom)

			assert.NoError(t, err)
			assert.Equal(t, tt.expectedCount, len(results))

			// Check each result
			for i, result := range results {
				assert.Equal(t, "Vulnerability Scanner", result.AgentName)

				if i < len(tt.expectedSeverities) {
					assert.Equal(t, tt.expectedSeverities[i], result.Severity)
				}

				if i < len(tt.expectedCVEs) {
					assert.Contains(t, result.Finding, tt.expectedCVEs[i])
				}

				assert.NotEmpty(t, result.Finding)
			}
		})
	}
}

func TestVulnerabilityScanningAgent_extractEcosystemFromPURL(t *testing.T) {
	agent := NewVulnerabilityScanningAgent()

	tests := []struct {
		name              string
		purl              string
		expectedEcosystem string
	}{
		{
			name:              "NPM package",
			purl:              "pkg:npm/lodash@4.17.21",
			expectedEcosystem: "npm",
		},
		{
			name:              "PyPI package",
			purl:              "pkg:pypi/requests@2.25.1",
			expectedEcosystem: "PyPI",
		},
		{
			name:              "Maven package",
			purl:              "pkg:maven/org.springframework/spring-core@5.3.8",
			expectedEcosystem: "Maven",
		},
		{
			name:              "Cargo package",
			purl:              "pkg:cargo/serde@1.0.136",
			expectedEcosystem: "crates.io",
		},
		{
			name:              "Go package",
			purl:              "pkg:golang/github.com/gin-gonic/gin@v1.7.2",
			expectedEcosystem: "Go",
		},
		{
			name:              "NuGet package",
			purl:              "pkg:nuget/Newtonsoft.Json@13.0.1",
			expectedEcosystem: "NuGet",
		},
		{
			name:              "Invalid PURL",
			purl:              "invalid-purl",
			expectedEcosystem: "",
		},
		{
			name:              "Empty PURL",
			purl:              "",
			expectedEcosystem: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ecosystem := agent.extractEcosystemFromPURL(tt.purl)
			assert.Equal(t, tt.expectedEcosystem, ecosystem)
		})
	}
}

func TestVulnerabilityScanningAgent_inferEcosystem(t *testing.T) {
	agent := NewVulnerabilityScanningAgent()

	tests := []struct {
		name              string
		componentName     string
		expectedEcosystem string
	}{
		{
			name:              "Maven-style package",
			componentName:     "org.springframework.boot",
			expectedEcosystem: "Maven",
		},
		{
			name:              "NPM-style package",
			componentName:     "@types/node",
			expectedEcosystem: "npm",
		},
		{
			name:              "Rust-style package",
			componentName:     "serde::json",
			expectedEcosystem: "crates.io",
		},
		{
			name:              "JAR file",
			componentName:     "spring-boot-starter.jar",
			expectedEcosystem: "Maven",
		},
		{
			name:              "Unknown package",
			componentName:     "unknown-package",
			expectedEcosystem: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ecosystem := agent.inferEcosystem(tt.componentName)
			assert.Equal(t, tt.expectedEcosystem, ecosystem)
		})
	}
}

func TestVulnerabilityScanningAgent_determineSeverity(t *testing.T) {
	agent := NewVulnerabilityScanningAgent()

	tests := []struct {
		name             string
		vulnerability    OSVVulnerability
		expectedSeverity string
	}{
		{
			name: "CVSS Critical score",
			vulnerability: OSVVulnerability{
				Severity: []struct {
					Type  string `json:"type"`
					Score string `json:"score"`
				}{
					{Type: "CVSS_V3", Score: "9.5"},
				},
			},
			expectedSeverity: "Critical",
		},
		{
			name: "CVSS High score",
			vulnerability: OSVVulnerability{
				Severity: []struct {
					Type  string `json:"type"`
					Score string `json:"score"`
				}{
					{Type: "CVSS_V3", Score: "7.8"},
				},
			},
			expectedSeverity: "High",
		},
		{
			name: "Database-specific Critical",
			vulnerability: OSVVulnerability{
				DatabaseSpecific: struct {
					Severity string `json:"severity"`
				}{Severity: "CRITICAL"},
			},
			expectedSeverity: "Critical",
		},
		{
			name: "CVE alias without other info",
			vulnerability: OSVVulnerability{
				Aliases: []string{"CVE-2023-12345"},
			},
			expectedSeverity: "High",
		},
		{
			name: "No severity information",
			vulnerability: OSVVulnerability{
				ID: "OSV-2023-001",
			},
			expectedSeverity: "Medium",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			severity := agent.determineSeverity(tt.vulnerability)
			assert.Equal(t, tt.expectedSeverity, severity)
		})
	}
}

func TestVulnerabilityScanningAgent_createFindingMessage(t *testing.T) {
	agent := NewVulnerabilityScanningAgent()

	tests := []struct {
		name             string
		component        core.Component
		vulnerability    OSVVulnerability
		expectedContains []string
	}{
		{
			name: "Component with version and CVE",
			component: core.Component{
				Name:    "test-package",
				Version: "1.0.0",
			},
			vulnerability: OSVVulnerability{
				ID:      "OSV-2023-001",
				Summary: "Test vulnerability",
				Aliases: []string{"CVE-2023-12345"},
			},
			expectedContains: []string{
				"test-package",
				"v1.0.0",
				"CVE-2023-12345",
				"Test vulnerability",
				"OSV-2023-001",
			},
		},
		{
			name: "Component without version",
			component: core.Component{
				Name: "no-version-package",
			},
			vulnerability: OSVVulnerability{
				ID:      "OSV-2023-002",
				Summary: "Another test vulnerability",
			},
			expectedContains: []string{
				"no-version-package",
				"Another test vulnerability",
				"OSV-2023-002",
			},
		},
		{
			name: "Vulnerability without summary",
			component: core.Component{
				Name:    "test-component",
				Version: "2.0.0",
			},
			vulnerability: OSVVulnerability{
				ID:      "OSV-2023-003",
				Aliases: []string{"CVE-2023-99999"},
			},
			expectedContains: []string{
				"test-component",
				"v2.0.0",
				"CVE-2023-99999",
				"OSV-2023-003",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			finding := agent.createFindingMessage(tt.component, tt.vulnerability)

			for _, expectedText := range tt.expectedContains {
				assert.Contains(t, finding, expectedText)
			}
		})
	}
}

func TestVulnerabilityScanningAgent_NetworkError(t *testing.T) {
	agent := NewVulnerabilityScanningAgent()
	// Set an invalid URL to simulate network error
	agent.apiBaseURL = "http://invalid-url:99999"

	sbom := core.SBOM{
		ID:   "test",
		Name: "Test SBOM",
		Components: []core.Component{
			{
				Name:    "test-component",
				Version: "1.0.0",
				PURL:    "pkg:npm/test-component@1.0.0",
			},
		},
	}

	ctx := context.Background()
	results, err := agent.Analyze(ctx, sbom)

	// Should not return error (graceful handling), but should have no results
	assert.NoError(t, err)
	assert.Equal(t, 0, len(results))
}

func TestVulnerabilityScanningAgent_ServerError(t *testing.T) {
	// Create mock server that returns server error
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(`{"error": "Internal server error"}`))
	}))
	defer mockServer.Close()

	agent := NewVulnerabilityScanningAgent()
	agent.apiBaseURL = mockServer.URL

	sbom := core.SBOM{
		ID:   "test",
		Name: "Test SBOM",
		Components: []core.Component{
			{
				Name:    "test-component",
				Version: "1.0.0",
				PURL:    "pkg:npm/test-component@1.0.0",
			},
		},
	}

	ctx := context.Background()
	results, err := agent.Analyze(ctx, sbom)

	// Should not return error (graceful handling), but should have no results
	assert.NoError(t, err)
	assert.Equal(t, 0, len(results))
}
